# ğŸ—ï¸ æ¶æ„æ”¹è¿›æ–¹æ¡ˆ

**ç‰ˆæœ¬:** 1.0  
**æ—¥æœŸ:** 2025-01-27  
**é€‚ç”¨é¡¹ç›®:** å¾…åŠè®°äº‹åº”ç”¨  
**æŠ€æœ¯æ ˆ:** Expo + React Native + TypeScript + SQLite  

## ğŸ“‹ é—®é¢˜åˆ†æ

åŸºäºä»£ç è¯„å®¡æŠ¥å‘Šï¼Œå½“å‰æ¶æ„å­˜åœ¨ä»¥ä¸‹ä¸»è¦é—®é¢˜ï¼š

1. **ä¾èµ–æ³¨å…¥ä¸å¤Ÿå®Œå–„** - å¤§é‡ä½¿ç”¨å•ä¾‹æ¨¡å¼ï¼Œå½±å“æµ‹è¯•æ€§
2. **ç¼ºå°‘Repositoryæ¥å£** - ç›´æ¥ä½¿ç”¨DAOï¼Œæ²¡æœ‰æŠ½è±¡å±‚
3. **ç¡¬ç¼–ç ä¾èµ–å…³ç³»** - æ¨¡å—é—´è€¦åˆåº¦è¾ƒé«˜
4. **ç¼ºå°‘é¢†åŸŸäº‹ä»¶** - ä¸šåŠ¡é€»è¾‘åˆ†æ•£ï¼Œæ‰©å±•æ€§å·®

---

## ğŸ¯ æ”¹è¿›ç›®æ ‡

- âœ… å®ç°å®Œæ•´çš„ä¾èµ–æ³¨å…¥å®¹å™¨
- âœ… å¼•å…¥Repositoryæ¨¡å¼æŠ½è±¡æ•°æ®è®¿é—®
- âœ… å»ºç«‹é¢†åŸŸäº‹ä»¶æœºåˆ¶
- âœ… æé«˜ä»£ç çš„å¯æµ‹è¯•æ€§å’Œå¯ç»´æŠ¤æ€§
- âœ… æ”¯æŒæœªæ¥æ•°æ®æºåˆ‡æ¢

---

## ğŸ”§ è¯¦ç»†æ”¹è¿›æ–¹æ¡ˆ

### 1. ä¾èµ–æ³¨å…¥å®¹å™¨å®ç°

#### 1.1 åˆ›å»ºIOCå®¹å™¨

```typescript
// lib/container/Container.ts
export interface ServiceDefinition {
  factory: (...args: any[]) => any;
  singleton?: boolean;
  dependencies?: string[];
}

export class Container {
  private services = new Map<string, ServiceDefinition>();
  private instances = new Map<string, any>();
  
  register<T>(name: string, definition: ServiceDefinition): void {
    this.services.set(name, definition);
  }
  
  resolve<T>(name: string): T {
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    const definition = this.services.get(name);
    if (!definition) {
      throw new Error(`Service ${name} not found`);
    }
    
    const dependencies = definition.dependencies?.map(dep => this.resolve(dep)) || [];
    const instance = definition.factory(...dependencies);
    
    if (definition.singleton !== false) {
      this.instances.set(name, instance);
    }
    
    return instance;
  }
}
```

#### 1.2 æœåŠ¡æ³¨å†Œé…ç½®

```typescript
// lib/container/ServiceRegistry.ts
import { Container } from './Container';
import { TaskService } from '../services/TaskService';
import { NoteService } from '../services/NoteService';
import { TaskRepository } from '../repositories/TaskRepository';

export function configureServices(container: Container): void {
  // æ³¨å†ŒRepository
  container.register('taskRepository', {
    factory: (db) => new TaskRepository(db),
    dependencies: ['database'],
    singleton: true
  });
  
  // æ³¨å†ŒService
  container.register('taskService', {
    factory: (repo, eventBus) => new TaskService(repo, eventBus),
    dependencies: ['taskRepository', 'eventBus'],
    singleton: true
  });
  
  // æ³¨å†Œäº‹ä»¶æ€»çº¿
  container.register('eventBus', {
    factory: () => new EventBus(),
    singleton: true
  });
}
```

### 2. Repositoryæ¨¡å¼å®ç°

#### 2.1 Repositoryæ¥å£å®šä¹‰

```typescript
// lib/repositories/interfaces/ITaskRepository.ts
export interface ITaskRepository {
  findById(id: string): Promise<TaskEntity | null>;
  findAll(options?: QueryOptions): Promise<TaskEntity[]>;
  create(task: CreateTaskData): Promise<TaskEntity>;
  update(id: string, data: UpdateTaskData): Promise<TaskEntity | null>;
  delete(id: string): Promise<boolean>;
  findByStatus(status: TaskStatus): Promise<TaskEntity[]>;
  findByProject(projectId: string): Promise<TaskEntity[]>;
  searchByTitle(query: string): Promise<TaskEntity[]>;
}

export interface QueryOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  filters?: Record<string, any>;
}
```

#### 2.2 Repositoryå®ç°

```typescript
// lib/repositories/TaskRepository.ts
import { ITaskRepository, QueryOptions } from './interfaces/ITaskRepository';
import { TaskDAO } from '../database/dao/TaskDAO';
import { TaskEntity, CreateTaskData, UpdateTaskData } from '../models/Task';

export class TaskRepository implements ITaskRepository {
  constructor(private taskDAO: TaskDAO) {}
  
  async findById(id: string): Promise<TaskEntity | null> {
    return await this.taskDAO.findById(id);
  }
  
  async findAll(options: QueryOptions = {}): Promise<TaskEntity[]> {
    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc' } = options;
    
    return await this.taskDAO.findWithOptions({
      offset: (page - 1) * limit,
      limit,
      orderBy: `${sortBy} ${sortOrder.toUpperCase()}`
    });
  }
  
  async create(data: CreateTaskData): Promise<TaskEntity> {
    const taskData = {
      ...data,
      id: generateUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    return await this.taskDAO.create(taskData);
  }
  
  async findByStatus(status: TaskStatus): Promise<TaskEntity[]> {
    return await this.taskDAO.findByStatus(status);
  }
  
  // ... å…¶ä»–æ–¹æ³•å®ç°
}
```

### 3. é¢†åŸŸäº‹ä»¶æœºåˆ¶

#### 3.1 äº‹ä»¶æ€»çº¿å®ç°

```typescript
// lib/events/EventBus.ts
export interface DomainEvent {
  eventType: string;
  aggregateId: string;
  occurredAt: Date;
  data: any;
}

export interface EventHandler {
  handle(event: DomainEvent): Promise<void>;
}

export class EventBus {
  private handlers = new Map<string, EventHandler[]>();
  
  subscribe(eventType: string, handler: EventHandler): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }
  
  async publish(event: DomainEvent): Promise<void> {
    const handlers = this.handlers.get(event.eventType) || [];
    
    await Promise.all(
      handlers.map(handler => handler.handle(event))
    );
  }
}
```

#### 3.2 é¢†åŸŸäº‹ä»¶å®šä¹‰

```typescript
// lib/events/TaskEvents.ts
export class TaskCreatedEvent implements DomainEvent {
  eventType = 'task.created';
  
  constructor(
    public aggregateId: string,
    public data: { task: TaskEntity },
    public occurredAt: Date = new Date()
  ) {}
}

export class TaskCompletedEvent implements DomainEvent {
  eventType = 'task.completed';
  
  constructor(
    public aggregateId: string,
    public data: { task: TaskEntity; completedAt: Date },
    public occurredAt: Date = new Date()
  ) {}
}
```

#### 3.3 äº‹ä»¶å¤„ç†å™¨

```typescript
// lib/events/handlers/StatisticsHandler.ts
export class StatisticsHandler implements EventHandler {
  constructor(private statisticsService: StatisticsService) {}
  
  async handle(event: DomainEvent): Promise<void> {
    switch (event.eventType) {
      case 'task.completed':
        await this.statisticsService.updateCompletionStats(event.aggregateId);
        break;
      case 'task.created':
        await this.statisticsService.updateTaskCountStats();
        break;
    }
  }
}
```

### 4. æœåŠ¡å±‚é‡æ„

#### 4.1 æœåŠ¡åŸºç±»

```typescript
// lib/services/BaseService.ts
export abstract class BaseService {
  constructor(
    protected eventBus: EventBus
  ) {}
  
  protected async publishEvent(event: DomainEvent): Promise<void> {
    await this.eventBus.publish(event);
  }
}
```

#### 4.2 TaskServiceé‡æ„

```typescript
// lib/services/TaskService.ts
export class TaskService extends BaseService {
  constructor(
    private taskRepository: ITaskRepository,
    protected eventBus: EventBus
  ) {
    super(eventBus);
  }
  
  async createTask(data: CreateTaskData): Promise<TaskDTO> {
    // ä¸šåŠ¡éªŒè¯
    this.validateTaskData(data);
    
    // åˆ›å»ºä»»åŠ¡
    const task = await this.taskRepository.create(data);
    
    // å‘å¸ƒäº‹ä»¶
    await this.publishEvent(new TaskCreatedEvent(task.id, { task }));
    
    return this.toDTO(task);
  }
  
  async completeTask(id: string): Promise<TaskDTO | null> {
    const task = await this.taskRepository.findById(id);
    if (!task) return null;
    
    // éªŒè¯çŠ¶æ€è½¬æ¢
    this.validateStatusTransition(task.status, TaskStatus.COMPLETED);
    
    // æ›´æ–°ä»»åŠ¡
    const updatedTask = await this.taskRepository.update(id, {
      status: TaskStatus.COMPLETED,
      completedAt: new Date()
    });
    
    if (updatedTask) {
      // å‘å¸ƒå®Œæˆäº‹ä»¶
      await this.publishEvent(
        new TaskCompletedEvent(id, { 
          task: updatedTask, 
          completedAt: updatedTask.completedAt! 
        })
      );
    }
    
    return updatedTask ? this.toDTO(updatedTask) : null;
  }
  
  private validateTaskData(data: CreateTaskData): void {
    if (!data.title?.trim()) {
      throw new ValidationError('ä»»åŠ¡æ ‡é¢˜ä¸èƒ½ä¸ºç©º');
    }
    
    if (data.title.length > 200) {
      throw new ValidationError('ä»»åŠ¡æ ‡é¢˜ä¸èƒ½è¶…è¿‡200ä¸ªå­—ç¬¦');
    }
  }
  
  private validateStatusTransition(from: TaskStatus, to: TaskStatus): void {
    const validTransitions = {
      [TaskStatus.TODO]: [TaskStatus.IN_PROGRESS, TaskStatus.COMPLETED],
      [TaskStatus.IN_PROGRESS]: [TaskStatus.TODO, TaskStatus.COMPLETED],
      [TaskStatus.COMPLETED]: [TaskStatus.TODO, TaskStatus.IN_PROGRESS]
    };
    
    if (!validTransitions[from]?.includes(to)) {
      throw new BusinessError(`æ— æ•ˆçš„çŠ¶æ€è½¬æ¢: ${from} -> ${to}`);
    }
  }
}
```

---

## ğŸ“¦ å®æ–½è®¡åˆ’

### Phase 1: åŸºç¡€è®¾æ–½ (1å‘¨)
- [ ] å®ç°IOCå®¹å™¨
- [ ] åˆ›å»ºäº‹ä»¶æ€»çº¿
- [ ] å®šä¹‰Repositoryæ¥å£
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•

### Phase 2: Repositoryé‡æ„ (1.5å‘¨)
- [ ] å®ç°TaskRepository
- [ ] å®ç°NoteRepository
- [ ] å®ç°ProjectRepository
- [ ] è¿ç§»ç°æœ‰DAOè°ƒç”¨

### Phase 3: æœåŠ¡å±‚é‡æ„ (1.5å‘¨)
- [ ] é‡æ„TaskService
- [ ] é‡æ„NoteService
- [ ] å®ç°äº‹ä»¶å¤„ç†å™¨
- [ ] ä¸šåŠ¡éªŒè¯è§„åˆ™

### Phase 4: æµ‹è¯•ä¸æ–‡æ¡£ (1å‘¨)
- [ ] å®Œå–„å•å…ƒæµ‹è¯•
- [ ] é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•
- [ ] æ–‡æ¡£æ›´æ–°

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```typescript
// __tests__/services/TaskService.test.ts
describe('TaskService', () => {
  let taskService: TaskService;
  let mockRepository: jest.Mocked<ITaskRepository>;
  let mockEventBus: jest.Mocked<EventBus>;
  
  beforeEach(() => {
    mockRepository = createMockRepository();
    mockEventBus = createMockEventBus();
    taskService = new TaskService(mockRepository, mockEventBus);
  });
  
  test('should create task and publish event', async () => {
    const taskData = { title: 'æµ‹è¯•ä»»åŠ¡', description: 'æè¿°' };
    const createdTask = { id: '123', ...taskData };
    
    mockRepository.create.mockResolvedValue(createdTask);
    
    const result = await taskService.createTask(taskData);
    
    expect(mockRepository.create).toHaveBeenCalledWith(taskData);
    expect(mockEventBus.publish).toHaveBeenCalledWith(
      expect.objectContaining({ eventType: 'task.created' })
    );
    expect(result).toMatchObject(taskData);
  });
});
```

---

## ğŸ“Š é¢„æœŸæ”¶ç›Š

### å¯æµ‹è¯•æ€§æå‡
- ä¾èµ–æ³¨å…¥æ”¯æŒMock
- äº‹ä»¶é©±åŠ¨æ¶æ„ä¾¿äºéš”ç¦»æµ‹è¯•
- Repositoryæ¨¡å¼ç®€åŒ–æ•°æ®å±‚æµ‹è¯•

### å¯ç»´æŠ¤æ€§æå‡
- æ¸…æ™°çš„å±‚æ¬¡ç»“æ„
- æ¾è€¦åˆçš„æ¨¡å—è®¾è®¡
- ç»Ÿä¸€çš„äº‹ä»¶å¤„ç†æœºåˆ¶

### æ‰©å±•æ€§æå‡
- æ”¯æŒå¤šç§æ•°æ®æº
- æ’ä»¶åŒ–äº‹ä»¶å¤„ç†
- æ¨¡å—åŒ–æœåŠ¡æ³¨å†Œ

### æ€§èƒ½ä¼˜åŒ–
- å•ä¾‹æ¨¡å¼å‡å°‘å¯¹è±¡åˆ›å»º
- äº‹ä»¶å¼‚æ­¥å¤„ç†
- æ•°æ®è®¿é—®å±‚ä¼˜åŒ–

---

## ğŸ”„ è¿ç§»ç­–ç•¥

### æ¸è¿›å¼è¿ç§»
1. ä¿æŒç°æœ‰ä»£ç è¿è¡Œ
2. é€æ­¥å¼•å…¥æ–°æ¶æ„
3. å¹¶è¡Œè¿è¡Œæ–°æ—§ä»£ç 
4. éªŒè¯åå®Œå…¨åˆ‡æ¢

### é£é™©æ§åˆ¶
- å……åˆ†çš„å•å…ƒæµ‹è¯•è¦†ç›–
- é›†æˆæµ‹è¯•éªŒè¯
- ç°åº¦å‘å¸ƒ
- å›æ»šæ–¹æ¡ˆ

### ç›‘æ§æŒ‡æ ‡
- APIå“åº”æ—¶é—´
- é”™è¯¯ç‡
- å†…å­˜ä½¿ç”¨
- æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½ 