# 🏗️ 架构改进方案

**版本:** 1.0  
**日期:** 2025-01-27  
**适用项目:** 待办记事应用  
**技术栈:** Expo + React Native + TypeScript + SQLite  

## 📋 问题分析

基于代码评审报告，当前架构存在以下主要问题：

1. **依赖注入不够完善** - 大量使用单例模式，影响测试性
2. **缺少Repository接口** - 直接使用DAO，没有抽象层
3. **硬编码依赖关系** - 模块间耦合度较高
4. **缺少领域事件** - 业务逻辑分散，扩展性差

---

## 🎯 改进目标

- ✅ 实现完整的依赖注入容器
- ✅ 引入Repository模式抽象数据访问
- ✅ 建立领域事件机制
- ✅ 提高代码的可测试性和可维护性
- ✅ 支持未来数据源切换

---

## 🔧 详细改进方案

### 1. 依赖注入容器实现

#### 1.1 创建IOC容器

```typescript
// lib/container/Container.ts
export interface ServiceDefinition {
  factory: (...args: any[]) => any;
  singleton?: boolean;
  dependencies?: string[];
}

export class Container {
  private services = new Map<string, ServiceDefinition>();
  private instances = new Map<string, any>();
  
  register<T>(name: string, definition: ServiceDefinition): void {
    this.services.set(name, definition);
  }
  
  resolve<T>(name: string): T {
    if (this.instances.has(name)) {
      return this.instances.get(name);
    }
    
    const definition = this.services.get(name);
    if (!definition) {
      throw new Error(`Service ${name} not found`);
    }
    
    const dependencies = definition.dependencies?.map(dep => this.resolve(dep)) || [];
    const instance = definition.factory(...dependencies);
    
    if (definition.singleton !== false) {
      this.instances.set(name, instance);
    }
    
    return instance;
  }
}
```

#### 1.2 服务注册配置

```typescript
// lib/container/ServiceRegistry.ts
import { Container } from './Container';
import { TaskService } from '../services/TaskService';
import { NoteService } from '../services/NoteService';
import { TaskRepository } from '../repositories/TaskRepository';

export function configureServices(container: Container): void {
  // 注册Repository
  container.register('taskRepository', {
    factory: (db) => new TaskRepository(db),
    dependencies: ['database'],
    singleton: true
  });
  
  // 注册Service
  container.register('taskService', {
    factory: (repo, eventBus) => new TaskService(repo, eventBus),
    dependencies: ['taskRepository', 'eventBus'],
    singleton: true
  });
  
  // 注册事件总线
  container.register('eventBus', {
    factory: () => new EventBus(),
    singleton: true
  });
}
```

### 2. Repository模式实现

#### 2.1 Repository接口定义

```typescript
// lib/repositories/interfaces/ITaskRepository.ts
export interface ITaskRepository {
  findById(id: string): Promise<TaskEntity | null>;
  findAll(options?: QueryOptions): Promise<TaskEntity[]>;
  create(task: CreateTaskData): Promise<TaskEntity>;
  update(id: string, data: UpdateTaskData): Promise<TaskEntity | null>;
  delete(id: string): Promise<boolean>;
  findByStatus(status: TaskStatus): Promise<TaskEntity[]>;
  findByProject(projectId: string): Promise<TaskEntity[]>;
  searchByTitle(query: string): Promise<TaskEntity[]>;
}

export interface QueryOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  filters?: Record<string, any>;
}
```

#### 2.2 Repository实现

```typescript
// lib/repositories/TaskRepository.ts
import { ITaskRepository, QueryOptions } from './interfaces/ITaskRepository';
import { TaskDAO } from '../database/dao/TaskDAO';
import { TaskEntity, CreateTaskData, UpdateTaskData } from '../models/Task';

export class TaskRepository implements ITaskRepository {
  constructor(private taskDAO: TaskDAO) {}
  
  async findById(id: string): Promise<TaskEntity | null> {
    return await this.taskDAO.findById(id);
  }
  
  async findAll(options: QueryOptions = {}): Promise<TaskEntity[]> {
    const { page = 1, limit = 20, sortBy = 'createdAt', sortOrder = 'desc' } = options;
    
    return await this.taskDAO.findWithOptions({
      offset: (page - 1) * limit,
      limit,
      orderBy: `${sortBy} ${sortOrder.toUpperCase()}`
    });
  }
  
  async create(data: CreateTaskData): Promise<TaskEntity> {
    const taskData = {
      ...data,
      id: generateUUID(),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    return await this.taskDAO.create(taskData);
  }
  
  async findByStatus(status: TaskStatus): Promise<TaskEntity[]> {
    return await this.taskDAO.findByStatus(status);
  }
  
  // ... 其他方法实现
}
```

### 3. 领域事件机制

#### 3.1 事件总线实现

```typescript
// lib/events/EventBus.ts
export interface DomainEvent {
  eventType: string;
  aggregateId: string;
  occurredAt: Date;
  data: any;
}

export interface EventHandler {
  handle(event: DomainEvent): Promise<void>;
}

export class EventBus {
  private handlers = new Map<string, EventHandler[]>();
  
  subscribe(eventType: string, handler: EventHandler): void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    this.handlers.get(eventType)!.push(handler);
  }
  
  async publish(event: DomainEvent): Promise<void> {
    const handlers = this.handlers.get(event.eventType) || [];
    
    await Promise.all(
      handlers.map(handler => handler.handle(event))
    );
  }
}
```

#### 3.2 领域事件定义

```typescript
// lib/events/TaskEvents.ts
export class TaskCreatedEvent implements DomainEvent {
  eventType = 'task.created';
  
  constructor(
    public aggregateId: string,
    public data: { task: TaskEntity },
    public occurredAt: Date = new Date()
  ) {}
}

export class TaskCompletedEvent implements DomainEvent {
  eventType = 'task.completed';
  
  constructor(
    public aggregateId: string,
    public data: { task: TaskEntity; completedAt: Date },
    public occurredAt: Date = new Date()
  ) {}
}
```

#### 3.3 事件处理器

```typescript
// lib/events/handlers/StatisticsHandler.ts
export class StatisticsHandler implements EventHandler {
  constructor(private statisticsService: StatisticsService) {}
  
  async handle(event: DomainEvent): Promise<void> {
    switch (event.eventType) {
      case 'task.completed':
        await this.statisticsService.updateCompletionStats(event.aggregateId);
        break;
      case 'task.created':
        await this.statisticsService.updateTaskCountStats();
        break;
    }
  }
}
```

### 4. 服务层重构

#### 4.1 服务基类

```typescript
// lib/services/BaseService.ts
export abstract class BaseService {
  constructor(
    protected eventBus: EventBus
  ) {}
  
  protected async publishEvent(event: DomainEvent): Promise<void> {
    await this.eventBus.publish(event);
  }
}
```

#### 4.2 TaskService重构

```typescript
// lib/services/TaskService.ts
export class TaskService extends BaseService {
  constructor(
    private taskRepository: ITaskRepository,
    protected eventBus: EventBus
  ) {
    super(eventBus);
  }
  
  async createTask(data: CreateTaskData): Promise<TaskDTO> {
    // 业务验证
    this.validateTaskData(data);
    
    // 创建任务
    const task = await this.taskRepository.create(data);
    
    // 发布事件
    await this.publishEvent(new TaskCreatedEvent(task.id, { task }));
    
    return this.toDTO(task);
  }
  
  async completeTask(id: string): Promise<TaskDTO | null> {
    const task = await this.taskRepository.findById(id);
    if (!task) return null;
    
    // 验证状态转换
    this.validateStatusTransition(task.status, TaskStatus.COMPLETED);
    
    // 更新任务
    const updatedTask = await this.taskRepository.update(id, {
      status: TaskStatus.COMPLETED,
      completedAt: new Date()
    });
    
    if (updatedTask) {
      // 发布完成事件
      await this.publishEvent(
        new TaskCompletedEvent(id, { 
          task: updatedTask, 
          completedAt: updatedTask.completedAt! 
        })
      );
    }
    
    return updatedTask ? this.toDTO(updatedTask) : null;
  }
  
  private validateTaskData(data: CreateTaskData): void {
    if (!data.title?.trim()) {
      throw new ValidationError('任务标题不能为空');
    }
    
    if (data.title.length > 200) {
      throw new ValidationError('任务标题不能超过200个字符');
    }
  }
  
  private validateStatusTransition(from: TaskStatus, to: TaskStatus): void {
    const validTransitions = {
      [TaskStatus.TODO]: [TaskStatus.IN_PROGRESS, TaskStatus.COMPLETED],
      [TaskStatus.IN_PROGRESS]: [TaskStatus.TODO, TaskStatus.COMPLETED],
      [TaskStatus.COMPLETED]: [TaskStatus.TODO, TaskStatus.IN_PROGRESS]
    };
    
    if (!validTransitions[from]?.includes(to)) {
      throw new BusinessError(`无效的状态转换: ${from} -> ${to}`);
    }
  }
}
```

---

## 📦 实施计划

### Phase 1: 基础设施 (1周)
- [ ] 实现IOC容器
- [ ] 创建事件总线
- [ ] 定义Repository接口
- [ ] 编写单元测试

### Phase 2: Repository重构 (1.5周)
- [ ] 实现TaskRepository
- [ ] 实现NoteRepository
- [ ] 实现ProjectRepository
- [ ] 迁移现有DAO调用

### Phase 3: 服务层重构 (1.5周)
- [ ] 重构TaskService
- [ ] 重构NoteService
- [ ] 实现事件处理器
- [ ] 业务验证规则

### Phase 4: 测试与文档 (1周)
- [ ] 完善单元测试
- [ ] 集成测试
- [ ] 性能测试
- [ ] 文档更新

---

## 🧪 测试策略

### 单元测试示例

```typescript
// __tests__/services/TaskService.test.ts
describe('TaskService', () => {
  let taskService: TaskService;
  let mockRepository: jest.Mocked<ITaskRepository>;
  let mockEventBus: jest.Mocked<EventBus>;
  
  beforeEach(() => {
    mockRepository = createMockRepository();
    mockEventBus = createMockEventBus();
    taskService = new TaskService(mockRepository, mockEventBus);
  });
  
  test('should create task and publish event', async () => {
    const taskData = { title: '测试任务', description: '描述' };
    const createdTask = { id: '123', ...taskData };
    
    mockRepository.create.mockResolvedValue(createdTask);
    
    const result = await taskService.createTask(taskData);
    
    expect(mockRepository.create).toHaveBeenCalledWith(taskData);
    expect(mockEventBus.publish).toHaveBeenCalledWith(
      expect.objectContaining({ eventType: 'task.created' })
    );
    expect(result).toMatchObject(taskData);
  });
});
```

---

## 📊 预期收益

### 可测试性提升
- 依赖注入支持Mock
- 事件驱动架构便于隔离测试
- Repository模式简化数据层测试

### 可维护性提升
- 清晰的层次结构
- 松耦合的模块设计
- 统一的事件处理机制

### 扩展性提升
- 支持多种数据源
- 插件化事件处理
- 模块化服务注册

### 性能优化
- 单例模式减少对象创建
- 事件异步处理
- 数据访问层优化

---

## 🔄 迁移策略

### 渐进式迁移
1. 保持现有代码运行
2. 逐步引入新架构
3. 并行运行新旧代码
4. 验证后完全切换

### 风险控制
- 充分的单元测试覆盖
- 集成测试验证
- 灰度发布
- 回滚方案

### 监控指标
- API响应时间
- 错误率
- 内存使用
- 数据库查询性能 