# 💾 数据库优化方案

**版本:** 1.0  
**日期:** 2025-01-27  
**适用项目:** 待办记事应用  
**技术栈:** Expo + React Native + TypeScript + SQLite  

## 📋 问题分析

根据代码评审报告，当前数据库层面存在以下主要问题：

1.  **数据验证不够严格**：`BaseDAO` 的 `create` 方法缺少对输入数据的验证，可能导致无效或格式错误的数据存入数据库。
2.  **缺少数据库连接池管理**：直接使用 SQLite 连接，在高并发或频繁操作下可能存在连接管理问题和潜在的性能瓶颈或连接泄漏风险。
3.  **查询优化空间**：
    *   部分复杂查询未使用联表（JOIN）操作，可能导致多次查询，影响效率。
    *   缺少对查询性能的监控和分析机制。
4.  **软删除实现查询复杂性**：虽然软删除保护数据，但在查询时需要额外处理 `is_deleted` 字段，可能使查询逻辑复杂化。

---

## 🎯 优化目标

-   ✅ 建立统一的数据验证层，确保入库数据的一致性和有效性。
-   ✅ 优化数据库连接管理，提高稳定性和性能。
-   ✅ 提升查询效率，减少不必要的数据库开销。
-   ✅ 引入查询性能监控，持续优化数据库操作。
-   ✅ 简化软删除数据的查询。

---

## 🔧 详细优化方案

### 1. 数据验证层实现

#### 1.1 引入验证库 (如 Zod 或 Yup)

在 `BaseDAO` 或服务层操作数据前，使用结构化的验证库对数据进行校验。

```typescript
// lib/models/validators/TaskValidators.ts
import { z } from 'zod';

export const CreateTaskSchema = z.object({
  title: z.string().min(1, "标题不能为空").max(200, "标题过长"),
  description: z.string().optional(),
  projectId: z.string().uuid().optional(),
  dueDate: z.date().optional(),
  priority: z.nativeEnum(TaskPriority).optional(),
  // ... 其他字段
});

export type CreateTaskInput = z.infer<typeof CreateTaskSchema>;

// lib/database/dao/BaseDAO.ts
// ... (其他代码)
abstract class BaseDAO<T extends BaseEntity, C, U> {
  // ...
  protected abstract getCreateSchema(): z.ZodSchema<C>; // 新增抽象方法
  protected abstract getUpdateSchema(): z.ZodSchema<U>; // 新增抽象方法

  async create(data: C): Promise<T> {
    try {
      const validatedData = this.getCreateSchema().parse(data);
      // ... 原有创建逻辑，使用 validatedData
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError("数据验证失败", error.errors);
      }
      throw error;
    }
  }

  async update(id: string, data: Partial<U>): Promise<T | null> {
    try {
      const validatedData = this.getUpdateSchema().partial().parse(data); // partial for updates
      // ... 原有更新逻辑，使用 validatedData
    } catch (error) {
      if (error instanceof z.ZodError) {
        throw new ValidationError("数据更新验证失败", error.errors);
      }
      throw error;
    }
  }
}

// lib/database/dao/TaskDAO.ts
// ...
class TaskDAO extends BaseDAO<TaskEntity, CreateTaskInput, UpdateTaskInput> {
  // ...
  protected getCreateSchema() {
    return CreateTaskSchema; // 实现抽象方法
  }
  protected getUpdateSchema() {
    return UpdateTaskSchema; // 实现抽象方法 (UpdateTaskSchema 需自行定义)
  }
  // ...
}
```

### 2. 数据库连接与事务管理优化

对于 Expo SQLite，它本身管理连接。但我们可以封装事务逻辑，确保其正确使用。

#### 2.1 确保事务的正确使用
评审报告中已提到 `withTransaction` 的实现是良好的。关键在于确保所有关联操作都在一个事务中执行，以保证数据一致性。

```typescript
// lib/services/TaskService.ts
async assignTaskToProject(taskId: string, projectId: string): Promise<void> {
  return this.database.withTransaction(async () => {
    const task = await this.taskDAO.findById(taskId);
    if (!task) throw new Error('Task not found');
    
    const project = await this.projectDAO.findById(projectId);
    if (!project) throw new Error('Project not found');

    task.projectId = projectId;
    await this.taskDAO.update(taskId, { projectId });

    // 可能还有其他关联操作，如更新项目任务数等
    await this.projectDAO.incrementTaskCount(projectId);
  });
}
```

**注意**: Expo SQLite 本身不提供传统的连接池。其 API (`SQLite.openDatabase()`) 返回一个数据库对象，该对象管理其自身的连接。重点是高效地使用这个单一连接，并通过事务来保证操作的原子性和一致性。避免在短时间内频繁打开和关闭数据库实例。

### 3. 查询性能优化

#### 3.1 索引优化
确保常用查询字段和 JOIN 条件字段已建立索引。

```sql
-- 示例：为 tasks 表的 projectId 和 status 字段创建索引
CREATE INDEX IF NOT EXISTS idx_tasks_project_id ON tasks (project_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks (status);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks (due_date);

-- 示例：为 notes 表的 task_id 创建索引
CREATE INDEX IF NOT EXISTS idx_notes_task_id ON notes (task_id);
```
在 `lib/database/migrations/` 中管理这些索引的创建。

#### 3.2 联表查询 (JOIN)
对于需要关联多个表数据的查询，使用 JOIN 替代多次单独查询。

```typescript
// lib/database/dao/TaskDAO.ts
async findTasksWithDetails(options: QueryOptions): Promise<TaskWithProjectAndNoteCount[]> {
  const query = `
    SELECT 
      t.*,
      p.name as project_name,
      (SELECT COUNT(*) FROM notes n WHERE n.task_id = t.id AND n.is_deleted = 0) as note_count
    FROM tasks t
    LEFT JOIN projects p ON t.project_id = p.id
    WHERE t.is_deleted = 0
    -- 其他条件如 options.filters, options.sortBy 等
    LIMIT ? OFFSET ?;
  `;
  const params = [options.limit, options.offset];
  // 根据 options.filters 动态添加 WHERE 子句和参数

  const results = await this.database.getAllAsync<any>(query, params);
  return results.map(row => ({
    // ... 转换 row 为 TaskWithProjectAndNoteCount 类型
  }));
}
```

#### 3.3 避免 SELECT *
只选择需要的字段，减少数据传输和处理开销。

```typescript
// 不推荐
// const tasks = await this.database.getAllAsync('SELECT * FROM tasks');

// 推荐
const taskTitles = await this.database.getAllAsync<{id: string, title: string}>(
  'SELECT id, title FROM tasks WHERE status = ?',
  [TaskStatus.TODO]
);
```

#### 3.4 查询分析 (SQLite EXPLAIN QUERY PLAN)
对于复杂或性能不佳的查询，使用 `EXPLAIN QUERY PLAN` 分析其执行计划，找出瓶颈。

```typescript
// 在开发或调试阶段执行
async analyzeQueryPerformance(sql: string, params: any[] = []) {
  const plan = await this.database.getAllAsync(`EXPLAIN QUERY PLAN ${sql}`, params);
  console.log('Query Plan:', plan);
  // 根据 plan 分析是否使用了索引，是否有全表扫描等
}

// 使用示例
// await taskDAO.analyzeQueryPerformance('SELECT * FROM tasks WHERE status = ?', ['TODO']);
```

### 4. 软删除查询优化

#### 4.1 创建视图 (View)
为活动记录创建视图，简化查询，避免在每个查询中都加入 `is_deleted = 0`。

```sql
-- migrations/00X_create_active_records_views.sql
CREATE VIEW active_tasks AS
SELECT * FROM tasks WHERE is_deleted = 0;

CREATE VIEW active_notes AS
SELECT * FROM notes WHERE is_deleted = 0;
```

之后查询时可以直接使用视图：
```typescript
// lib/database/dao/TaskDAO.ts
async findAllActive(options: QueryOptions): Promise<TaskEntity[]> {
  // 直接查询 active_tasks 视图
  const results = await this.database.getAllAsync<TaskEntity>(
    'SELECT * FROM active_tasks ORDER BY createdAt DESC LIMIT ? OFFSET ?',
    [options.limit, options.offset]
  );
  return results;
}
```
**注意**: 视图本身不存储数据，是对查询的封装。对于写操作（INSERT, UPDATE, DELETE），仍需操作基表。

### 5. 数据库性能监控和日志

#### 5.1 记录慢查询
封装数据库执行方法，记录执行时间超过阈值的查询。

```typescript
// lib/database/SQLiteDatabase.ts (或类似封装类)
async getAllAsync<T>(sql: string, params: any[] = []): Promise<T[]> {
  const startTime = performance.now();
  try {
    return await this.db.getAllAsync<T>(sql, params);
  } finally {
    const duration = performance.now() - startTime;
    if (duration > SLOW_QUERY_THRESHOLD_MS) { // SLOW_QUERY_THRESHOLD_MS = 50ms 例如
      console.warn(`Slow query (${duration.toFixed(2)}ms): ${sql}`, params);
      // 可以集成到更完善的日志系统
    }
  }
}
// 对 runAsync, getAsync 等方法也做类似处理
```

#### 5.2 定期数据库维护 (PRAGMA optimize)
SQLite 提供了 `PRAGMA optimize;` 命令，可以运行一些优化操作。

```typescript
// 可以在应用启动时或低峰期执行
async optimizeDatabase() {
  try {
    await this.database.runAsync('PRAGMA optimize;');
    console.log('Database optimization complete.');
  } catch (error) {
    console.error('Database optimization failed:', error);
  }
}
```

---

## 📦 实施计划

### Phase 1: 数据验证与基础优化 (1周)
-   [ ] 引入 Zod 并为核心模型添加验证 Schema。
-   [ ] 在 `BaseDAO` 中集成数据验证逻辑。
-   [ ] Review并确保关键的跨表操作使用事务。
-   [ ] 添加基础索引 (主键、外键、常用查询字段)。

### Phase 2: 查询重构与视图 (1.5周)
-   [ ] 识别并重构性能敏感的查询，优先使用 JOIN。
-   [ ] 推广 `SELECT <specific_columns>` 替代 `SELECT *`。
-   [ ] 为软删除表创建 `active_...` 视图并更新DAO方法。
-   [ ] 实现查询分析辅助函数。

### Phase 3: 性能监控与维护 (1周)
-   [ ] 实现慢查询日志记录。
-   [ ] 集成 `PRAGMA optimize` 到应用生命周期中。
-   [ ] 使用 `EXPLAIN QUERY PLAN` 分析几个核心查询并记录优化前后对比。

### Phase 4: 测试与文档 (1周)
-   [ ] 针对新的验证逻辑和查询方法补充单元/集成测试。
-   [ ] 更新数据库相关文档，包括 Schema、索引策略、视图信息。
-   [ ] 进行一轮针对性的性能测试。

---

## 📊 预期收益

-   **数据质量提升**：通过严格的数据验证，减少脏数据和潜在错误。
-   **查询性能提升**：通过索引、JOIN优化和视图，加快数据检索速度，降低UI响应延迟。
-   **应用稳定性增强**：更可靠的事务管理和数据验证。
-   **可维护性改善**：视图简化查询逻辑，结构化验证使代码更清晰。
-   **问题定位加速**：慢查询日志和查询计划分析有助于快速定位和解决数据库瓶颈。

---

## ⚠️ 注意事项

-   **Expo SQLite 限制**: 它是一个轻量级的 SQLite 实现，不支持所有高级数据库功能。优化需在此范围内进行。
-   **过度索引**: 过多的索引会增加写操作的开销，需要权衡读写性能。
-   **迁移管理**: 所有数据库结构变更（表、索引、视图）都应通过迁移脚本进行管理。 